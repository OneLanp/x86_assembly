# 02 ASM tour - hello world

## 1.编译
````bash
nasm hello.asm -o hello.bin
````
将asm文件通过nasm汇编变成bin文件

## 2.写入磁盘
````bash
dd if=hello.bin of=master.img bs=512 count=1 conv=notrunc
````

## 3.Tips
### ds - 数据段寄存器
### x86的寻址方式是：段寄存器 * 16 + 地址

````asm
mov ax, 0xb800
mov ds, ax

#如果没有为 [0]指定数据段，那么其数据段默认是ds，并将其初始化为0xb800
#此处将数据段0xb800位置的空间填入0x41也就是ASCII的大写A
mov byte [0], 'A'

#随后进入阻塞，使得程序停止
halt:
    jmp halt
    //第10行意思是从halt开始到510(0x55),511(0xaa)之间的存储空间填充0
times 510 - ($ - $$) db 0
//$-当前这一行代码的位置
//$$-是这个段开始的位置，此处为0
//510-($- $$)就是说明除去最后的两个字节，为510字节，然后得到第10行的位置，相减就能知道中间部分的字节块大小了
//512字节的最后两个字节，55和AA
times 510 - ($ - $$) db 0
db 0x55, 0xaa
````

## 4.启动过程
x86上电之后，cs寄存器的值默认为：0xf000，并会执行jmpf 0xf000:e05b指令，随后ip寄存器的值就变成了0000e05b，程序就跳转至e05b的位置开始顺序执行，此部分是boot程序，它会确认硬件工作状态（硬件自检），然后启动磁盘引导程序，将引导至首个磁盘的主引导扇区，其编号为0。
随后将定位至0x7c00，这个位置就是我们的master.img磁盘的首地址,执行程序后，0x7c00的内容变成下图
![Alt text](image-2.png)
每个扇区的最后两个字节是55 AA，表示这个主引导扇区是有效的，如果不是就是无效的，无法启动我们的hello
.bin内的程序


## 5.实模式下内存区域的表格

| 起始地址  | 结束地址  | 大小     | 用途               |
| --------- | --------- | -------- | ------------------ |
| `0x000`   | `0x3FF`   | 1KB      | 中断向量表         |
| `0x400`   | `0x4FF`   | 256B     | BIOS 数据区        |
| `0x500`   | `0x7BFF`  | 29.75 KB | 可用区域           |
| `0x7C00`  | `0x7DFF`  | 512B     | MBR 加载区域       |
| `0x7E00`  | `0x9FBFF` | 607.6KB  | 可用区域           |
| `0x9FC00` | `0x9FFFF` | 1KB      | 扩展 BIOS 数据区   |
| `0xA0000` | `0xAFFFF` | 64KB     | 用于彩色显示适配器 |
| `0xB0000` | `0xB7FFF` | 32KB     | 用于黑白显示适配器 |
| `0xB8000` | `0xBFFFF` | 32KB     | 用于文本显示适配器 |
| `0xC0000` | `0xC7FFF` | 32KB     | 显示适配器 BIOS    |
| `0xC8000` | `0xEFFFF` | 160KB    | 映射内存           |
| `0xF0000` | `0xFFFEF` | 64KB-16B | 系统 BIOS          |
| `0xFFFF0` | `0xFFFFF` | 16B      | 系统 BIOS 入口地址 |

My API
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